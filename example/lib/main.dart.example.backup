import 'dart:async';
import 'dart:io';
import 'dart:typed_data';
import 'dart:ui' as ui;

import 'package:custom_quick_alert/custom_quick_alert.dart';
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Custom Quick Alert Capture',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      debugShowCheckedModeBanner: false,
      home: const AlertCaptureScreen(),
    );
  }
}

class AlertCaptureScreen extends StatefulWidget {
  const AlertCaptureScreen({super.key});

  @override
  State<AlertCaptureScreen> createState() => _AlertCaptureScreenState();
}

class _AlertCaptureScreenState extends State<AlertCaptureScreen> {
  final GlobalKey _alertKey = GlobalKey();
  final List<GlobalKey> _individualAlertKeys =
      <GlobalKey<State<StatefulWidget>>>[];
  bool _shouldRenderAlert = true;

  @override
  void initState() {
    super.initState();

    // Initialize keys for each alert type (7 alerts total)
    for (int i = 0; i < 7; i++) {
      _individualAlertKeys.add(GlobalKey());
    }

    WidgetsBinding.instance.addPostFrameCallback((_) async {
      await _captureAllAlerts();

      setState(() {
        _shouldRenderAlert = true;
      });
    });
  }

  Future<void> _captureAllAlerts() async {
    final List<String> alertNames = <String>[
      'success_dialog',
      'error_dialog',
      'warning_dialog',
      'info_dialog',
      'confirm_dialog',
      'custom_dialog',
      'loading_dialog',
    ];

    for (int i = 0; i < _individualAlertKeys.length; i++) {
      await Future<dynamic>.delayed(const Duration(milliseconds: 1000));
      debugPrint('Capturing alert: ${alertNames[i]}');
      // Capture each individual alert
      await _captureIndividualAlert(_individualAlertKeys[i], alertNames[i]);
    }
  }

  Future<void> _captureIndividualAlert(GlobalKey key, String fileName) async {
    try {
      final RenderRepaintBoundary? boundary =
          key.currentContext?.findRenderObject() as RenderRepaintBoundary?;
      if (boundary == null) {
        debugPrint('❌ Could not find boundary to capture for $fileName');
        return;
      }

      final ui.Image image = await boundary.toImage(pixelRatio: 5.0);
      final ByteData? byteData =
          await image.toByteData(format: ui.ImageByteFormat.png);
      final Uint8List pngBytes = byteData!.buffer.asUint8List();

      final Directory dir = await getApplicationDocumentsDirectory();
      final Directory subdir = Directory('${dir.path}/capture');
      if (!await subdir.exists()) {
        await subdir.create(recursive: true);
      }

      final String filePath = path.join(subdir.path, '$fileName.png');
      final File file = File(filePath);
      await file.writeAsBytes(pngBytes);

      debugPrint('✅ $fileName image saved to: $filePath');
    } catch (e) {
      debugPrint('❌ Error capturing $fileName image: $e');
    }
  }

  Future<void> _captureAndSaveAlert() async {
    try {
      final RenderRepaintBoundary? boundary = _alertKey.currentContext
          ?.findRenderObject() as RenderRepaintBoundary?;
      if (boundary == null) {
        debugPrint('❌ Could not find boundary to capture');
        return;
      }

      final ui.Image image = await boundary.toImage(pixelRatio: 5.0);
      final ByteData? byteData =
          await image.toByteData(format: ui.ImageByteFormat.png);
      final Uint8List pngBytes = byteData!.buffer.asUint8List();

      final Directory dir = await getApplicationDocumentsDirectory();
      final Directory subdir = Directory('${dir.path}/capture');
      if (!await subdir.exists()) {
        await subdir.create(recursive: true);
      }

      final String filePath = path.join(subdir.path, 'all_alerts_combined.png');
      final File file = File(filePath);
      await file.writeAsBytes(pngBytes);

      debugPrint('✅ Combined image saved to: $filePath');

      // Also capture individual alerts
      await _captureAllAlerts();
    } catch (e) {
      debugPrint('❌ Error capturing image: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: Center(
        child: _shouldRenderAlert
            ? RepaintBoundary(
                key: _alertKey,
                child: SingleChildScrollView(
                  child: Column(
                    children: <Widget>[alertCaptureScreen()],
                  ),
                ),
              )
            : const Text('Alert has been captured and saved.'),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _captureAndSaveAlert,
        tooltip: 'Capture Alert',
        child: const Icon(Icons.camera_alt),
      ),
    );
  }

  @override
  void dispose() {
    _alertKey.currentContext?.findRenderObject()?.dispose();
    for (final GlobalKey key in _individualAlertKeys) {
      key.currentContext?.findRenderObject()?.dispose();
    }
    super.dispose();
  }

  Widget alertCaptureScreen() {
    final List<Widget> alerts = <Widget>[
      RepaintBoundary(
        key: _individualAlertKeys[0],
        child: CustomQuickAlertPage.successAlert(
          title: 'Success',
          message: 'Your operation was successful!',
          onConfirm: () => debugPrint('Success alert confirmed'),
        ),
      ),
      RepaintBoundary(
        key: _individualAlertKeys[1],
        child: CustomQuickAlertPage.errorAlert(
          title: 'Error',
          message: 'An error occurred. Please try again.',
          onConfirm: () => debugPrint('Error alert confirmed'),
        ),
      ),
      RepaintBoundary(
        key: _individualAlertKeys[2],
        child: CustomQuickAlertPage.warningAlert(
          title: 'Warning',
          message: 'This is a warning message.',
          confirmBtnColor: Colors.orange,
          confirmTextColor: Colors.white,
          onConfirm: () => debugPrint('Warning alert confirmed'),
        ),
      ),
      RepaintBoundary(
        key: _individualAlertKeys[3],
        child: CustomQuickAlertPage.infoAlert(
          title: 'Information',
          message: 'This is an informational message.',
          onConfirm: () => debugPrint('Info alert confirmed'),
        ),
      ),
      RepaintBoundary(
        key: _individualAlertKeys[4],
        child: CustomQuickAlertPage.confirmAlert(
          title: 'Confirm',
          message: 'Are you sure you want to proceed?',
          onConfirm: () => debugPrint('Confirm alert confirmed'),
          onCancel: () => debugPrint('Confirm alert cancelled'),
        ),
      ),
      RepaintBoundary(
        key: _individualAlertKeys[5],
        child: CustomQuickAlertPage.customAlert(
          title: 'Custom Alert',
          message: 'This is a custom alert with your own widget.',
          lottieAsset: 'assets/animations/custom.json',
          confirmText: 'Confirm',
          cancelText: 'Cancel',
          confirmBtnColor: Colors.blue,
          cancelBtnColor: Colors.red,
          onConfirm: () {
            // You can add your own logic here for the confirm action.
          },
          onCancel: () {
            // You can add your own logic here for the cancel action.
          },
          position: CustomQuickAlertPosition.center,
          animType: CustomQuickAlertAnimType.scale,
          customContent: Container(
            padding: const EdgeInsets.all(16.0),
            decoration: BoxDecoration(
              color: Colors.grey[100],
              borderRadius: BorderRadius.circular(12),
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: <Widget>[
                const Icon(Icons.star, color: Colors.amber, size: 48),
                const SizedBox(height: 12),
                Text(
                  'This is a custom widget inside the alert!',
                  style: TextStyle(
                    fontSize: 16,
                    color: Colors.grey[800],
                    fontWeight: FontWeight.w500,
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        ),
      ),
      RepaintBoundary(
        key: _individualAlertKeys[6],
        child: CustomQuickAlertPage.loadingAlert(
          title: 'Loading',
          message: 'Fetching your data',
          lottieRepeat: false,
          lottieAsset: 'assets/animations/loading.json',
          animType: CustomQuickAlertAnimType.scale,
          onConfirm: () => debugPrint('Loading alert confirmed'),
        ),
      ),
    ];

    return ListView(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      children: alerts,
    );
  }
}
